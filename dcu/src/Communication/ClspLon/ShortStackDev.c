/*  
 *   File: ShortStackDev.c
 *   Generated by LonTalk Interface Developer 4.00.11
 *
 *   Created on Mon May 14 09:10:26 2012
 *   This file applies to the device with program ID 9F:FF:FF:00:00:00:04:00
 *
 *   Copyright (c) Echelon Corporation 2002-2009
 *   All rights reserved.
 *
 *   This file is Example Software as defined in the Software
 *   License Agreement that governs its use.
 *
 *   ECHELON MAKES NO REPRESENTATION, WARRANTY, OR CONDITION OF
 *   ANY KIND, EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE OR IN
 *   ANY COMMUNICATION WITH YOU, INCLUDING, BUT NOT LIMITED TO,
 *   ANY IMPLIED WARRANTIES OF MERCHANTABILITY, SATISFACTORY
 *   QUALITY, FITNESS FOR ANY PARTICULAR PURPOSE, 
 *   NONINFRINGEMENT, AND THEIR EQUIVALENTS.
 */
#if !defined(DEFINED_SHORTSTACKDEV_C)
#define DEFINED_SHORTSTACKDEV_C

#include <string.h>
#include "ShortStackDev.h"
#include "ShortStackApi.h"

/*
 *  Network Variables
 *  The device's network variables are being declared here.
 *  Input network variables are automatically updated by the
 *  ShortStack API, with the help of the network variable definitions
 *  table and the LonEventHandler function. The application receives
 *  notification through the LonNvUpdateOccurred callback. 
 *  Output network variables must be written to by the application,
 *  just like any other global variable may be written to. For
 *  output network variables, the application must also call the 
 *  LonPropagateNv() API function to submit the updated output
 *  network variable data to the ShortStack Micro Server.
 */
volatile /* cp */ SCPTnwrkCnfg nciNetConfig = 1u;    /* sd_string("&1,0,0\x80,25") */

volatile SNVT_obj_request nviRequest;          /* sd_string("@0|1") */

SNVT_obj_status nvoStatus;                     /* sd_string("@0|2") */

volatile SNVT_switch nviLight[2];              /* sd_string("@1|1" ... "@2|1") */

SNVT_switch nvoLightFb[2];                     /* sd_string("@1|2" ... "@2|2") */

SNVT_switch nvoSwitch[2];                      /* sd_string("@3|2" ... "@4|2") */

volatile SNVT_switch nviSwitchFb[2];           /* sd_string("@3|1" ... "@4|1") */



/*
 *  Self-identification data
 *  DO NOT EDIT
 */
static const LonByte siData[] =
{
    0x01, 0x15, 0x0B, 0x01, 0x00, 0x01, 0x8F, 0x45, 
    0x8E, 0x5C, 0xCE, 0x5D, 0x8E, 0x5F, 0x8E, 0x5F, 
    0x8E, 0x5F, 0x8E, 0x5F, 0x8E, 0x5F, 0x8E, 0x5F, 
    0x8E, 0x5F, 0x8E, 0x5F, 0x26, 0x33, 0x2E, 0x34, 
    0x40, 0x30, 0x4E, 0x6F, 0x64, 0x65, 0x4F, 0x62, 
    0x6A, 0x65, 0x63, 0x74, 0x2C, 0x34, 0x5B, 0x32, 
    0x46, 0x62, 0x4C, 0x69, 0x67, 0x68, 0x74, 0x2C, 
    0x32, 0x5B, 0x32, 0x46, 0x62, 0x53, 0x77, 0x69, 
    0x74, 0x63, 0x68, 0x00, 0x30, 0x6E, 0x63, 0x69, 
    0x4E, 0x65, 0x74, 0x43, 0x6F, 0x6E, 0x66, 0x69, 
    0x67, 0x00, 0x26, 0x31, 0x2C, 0x30, 0x2C, 0x30, 
    0x80, 0x2C, 0x32, 0x35, 0x00, 0x30, 0x6E, 0x76, 
    0x69, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 
    0x00, 0x40, 0x30, 0x7C, 0x31, 0x00, 0x30, 0x6E, 
    0x76, 0x6F, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 
    0x00, 0x40, 0x30, 0x7C, 0x32, 0x00, 0x30, 0x6E, 
    0x76, 0x69, 0x4C, 0x69, 0x67, 0x68, 0x74, 0x5F, 
    0x31, 0x00, 0x40, 0x31, 0x7C, 0x31, 0x00, 0x30, 
    0x6E, 0x76, 0x69, 0x4C, 0x69, 0x67, 0x68, 0x74, 
    0x5F, 0x32, 0x00, 0x40, 0x32, 0x7C, 0x31, 0x00, 
    0x30, 0x6E, 0x76, 0x6F, 0x4C, 0x69, 0x67, 0x68, 
    0x74, 0x46, 0x62, 0x5F, 0x31, 0x00, 0x40, 0x31, 
    0x7C, 0x32, 0x00, 0x30, 0x6E, 0x76, 0x6F, 0x4C, 
    0x69, 0x67, 0x68, 0x74, 0x46, 0x62, 0x5F, 0x32, 
    0x00, 0x40, 0x32, 0x7C, 0x32, 0x00, 0x30, 0x6E, 
    0x76, 0x6F, 0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 
    0x5F, 0x31, 0x00, 0x40, 0x33, 0x7C, 0x32, 0x00, 
    0x30, 0x6E, 0x76, 0x6F, 0x53, 0x77, 0x69, 0x74, 
    0x63, 0x68, 0x5F, 0x32, 0x00, 0x40, 0x34, 0x7C, 
    0x32, 0x00, 0x30, 0x6E, 0x76, 0x69, 0x53, 0x77, 
    0x69, 0x74, 0x63, 0x68, 0x46, 0x62, 0x5F, 0x31, 
    0x00, 0x40, 0x33, 0x7C, 0x31, 0x00, 0x30, 0x6E, 
    0x76, 0x69, 0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 
    0x46, 0x62, 0x5F, 0x32, 0x00, 0x40, 0x34, 0x7C, 
    0x31, 0x00, 0x7F, 0x00, 0x7F
};

/*
 *  Application initialization data
 *  DO NOT EDIT
 */
static const LonByte appInitData[] =
{
    /* 16-bit application signature: */
    LON_APP_SIGNATURE/256u, LON_APP_SIGNATURE%256u,
    /* program Id: */
    0x9F, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x04, 0x00, 
    /* communication parameters: */
    0x37, 0x2E, 0x16, 0x09, 0x1A, 0x2B, 0x2C, 0x00, 
    0x04, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 
    /* preferences */
    LON_EXPLICIT_ADDRESSING | LON_SERVICE_PIN_TIMER,
    /* number of static network variables: */
    0x0B, 
    /* one configuration byte per network variable: */
    0x00, 0x00, 0x40, 0x00, 0x00, 0x60, 0x60, 0x50, 
    0x50, 0x00, 0x00
};

/*
 *  Network Variable Table
 *  The network variable table nvTable[] is defined here, where each element
 *  of that array has the structure detailed in the following definition.
 */

#define NVPTR  volatile void* const    /* helper for following table */

static const LonNvDescription nvTable[] =
{ /*          name            declared size                           flags */
   { (NVPTR)&nciNetConfig,   (LonByte)sizeof(SCPTnwrkCnfg),           LON_NVDESC_PERSISTENT_MASK },
   { (NVPTR)&nviRequest,     (LonByte)sizeof(SNVT_obj_request),       0 },
   { (NVPTR)&nvoStatus,      (LonByte)sizeof(SNVT_obj_status),        LON_NVDESC_OUTPUT_MASK+LON_NVDESC_SYNC_MASK },
   { (NVPTR)&nviLight[0],    (LonByte)sizeof(SNVT_switch),            0 },
   { (NVPTR)&nviLight[1],    (LonByte)sizeof(SNVT_switch),            0 },
   { (NVPTR)&nvoLightFb[0],  (LonByte)sizeof(SNVT_switch),            LON_NVDESC_OUTPUT_MASK },
   { (NVPTR)&nvoLightFb[1],  (LonByte)sizeof(SNVT_switch),            LON_NVDESC_OUTPUT_MASK },
   { (NVPTR)&nvoSwitch[0],   (LonByte)sizeof(SNVT_switch),            LON_NVDESC_OUTPUT_MASK },
   { (NVPTR)&nvoSwitch[1],   (LonByte)sizeof(SNVT_switch),            LON_NVDESC_OUTPUT_MASK },
   { (NVPTR)&nviSwitchFb[0], (LonByte)sizeof(SNVT_switch),            0 },
   { (NVPTR)&nviSwitchFb[1], (LonByte)sizeof(SNVT_switch),            0 }
}; /* end of Nv table */

/*
 * Constant: mtTable
 * Message Tag table  
 *
 * The message tag table mtTable[] is defined here, where each element
 * of that array indicates whether the respective message tag can be used
 * for implicit addressing (it cannot be bound through the address table).
 * This is the case for all message tags that have been declared with the 
 * bind_info(nonbind) modifier.
 */
static const LonMtDescription mtTable[] =
{
    FALSE      /* tag allows for implicit addressing */
}; /* end of MT table */

const LonByte* LonGetSiData(unsigned* pLength)
{
    *pLength = (unsigned)sizeof(siData);
    return siData;
}

const LonByte* LonGetAppInitData(void)
{
    return appInitData;
}

const LonNvDescription* const LonGetNvTable(void)
{
    return nvTable;
}

const LonMtDescription* const LonGetMtTable(void)
{
    return mtTable;
}

#endif  /* defined(DEFINED_SHORTSTACKDEV_C) */
/* end of file. */
